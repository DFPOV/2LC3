â€” Homework 4 Notebook 1: Natural Numbers and Induction
[1]
Here we develop a theory of the natural numbers based on induction over zero 0 and successor suc_.

The advantage of making successor a unary prefix operator is that we can write suc suc suc 0 without parentheses. (We give it the same precedence as the other unary prefix operators.)

Besides equality _=_ and the material from Homework 3 (â‰¡, Â¬, â‰¢), the following are already provided here:

Declaration: â„• : Type
Declaration: suc_ : â„• â†’ â„•
Evaluation is not available here, and Facts only can involve natural-number literals and suc_, for example, â€œFact `suc suc 1 = 3`â€.

Only one hint item is allowed per hint.

[2]
Recall from the lecture that the induction principle for the natural numbers states that for proving a property P involving a variable m : â„•, it is sufficient to prove both of the following:

the base case P[m â‰” 0], and
the induction step P â‡’ P[m â‰” suc m].
Proving the induction step is normally presented as a proof of P[m â‰” suc m] which is allowed to use P (which you may understand as P[m â‰” m]) as induction hypothesis.

In CalcCheck, simple induction proofs for properties of the natural numbers have the following shape, assuming that P is an expression of type ğ”¹ involving the variable m of type â„•:

Theorem â€œProperty `P`â€: P
Proof:
  By induction on `m : â„•`:
    Base case `P[m â‰” 0]`:
        ?
    Induction step `P[m â‰” suc m]`:
        ?
      =âŸ¨ ? âŸ©
        ?
      =âŸ¨ Induction hypothesis `P` âŸ©
        ?
      =âŸ¨ ? âŸ©
        ?
(This particular shape assumes an equality calculation for the induction step, but any kind of proof can be used there instead, and it can invoke the Induction hypothesis.)

That is:

The Base case needs to contain a proof for P[m â‰” 0].
The Induction step needs to contain a proof for P[m â‰” suc m].
The proof for the Induction step may use the Induction hypothesis, which is the theorem statement P itself.
Induction hypothesis is now a new key-phrase hint item.

The explicit expressions can also be omitted, so that the above pattern then changes to the following:

Theorem â€œProperty `P`â€: P
Proof:
  By induction on `m : â„•`:
    Base case:
        ?
    Induction step:
        ?
      =âŸ¨ ? âŸ©
        ?
      =âŸ¨ Induction hypothesis âŸ©
        ?
      =âŸ¨ ? âŸ©
        ?
For the invocation of the Induction hypothesis, however, omitting the explicit expression is only allowed where only one induction hypothesis is in scope; in nested inductions where there are more than one, the expression after Induction hypothesis is always required.

Important: The induction hypothesis can only be used directly, not in substitution instances.

[3]
Addition
[4]
Declaration: _+_ : â„• â†’ â„• â†’ â„•

Declaration: _+_ : â„• â†’ (â„• â†’ â„•)   
    â€” CalcCheck: Operator _+_: Associating to the left; precedence 100
[5]
The following two axioms constitute an inductive definition of the binary infix operator +; they cover all cases for the two arguments:

since the first argument is of type â„•, it is equal to either 0 or, for some m : â„•, to suc m;
in either case, the second argument is the not-yet-mentioned variable n, which can be instantiated with all possible (type-correct) second arguments of +.
[6]
Axiom â€œDefinition of + for 0â€
      â€œLeft-identity of +â€:           0 + n = n
Axiom â€œDefinition of + for `suc`â€:  (suc m) + n = suc (m + n)

Axiom â€œDefinition of + for 0â€ â€œLeft-identity of +â€: 0 + n = n
Axiom â€œDefinition of + for `suc`â€: suc m + n = suc (m + n)
[7]
Proving properties of inductively-defined functions frequently requires induction proofs; here is an example:

[8]
Theorem â€œRight-identity of +â€: m + 0 = m
Proof:
  By induction on `m : â„•`:
    Base case:
        0 + 0
      =âŸ¨ â€œDefinition of + for 0â€ âŸ©
        0
    Induction step:
        suc m + 0
      =âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
        suc (m + 0)
      =âŸ¨ Induction hypothesis âŸ©
        suc m

Theorem â€œRight-identity of +â€: m + 0 = m
Proof:
    By induction on `m : â„•`:
        Base case:
            Calculation for expected goal  `0 + 0 = 0`:
                    0 + 0
                = âŸ¨ â€œDefinition of + for 0â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for 0â€
                        â€” CalcCheck: â”€ OK
                    0            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK
        Induction step:
            Calculation for expected goal  `suc m + 0 = suc m`:
                    suc m + 0
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc (m + 0)
                = âŸ¨ Induction hypothesis âŸ©
                        â€” CalcCheck: Found induction hypothesis `m + 0 = m`
                        â€” CalcCheck: â”€ OK
                    suc m            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK    
    â€” CalcCheck: Base case and induction step both present   
    â€” CalcCheck: Induction proof OK
[9]
The successor operator suc can now be explained as a special case of addition. Replace the question marks with hint items â€” remember that Induction hypothesis is now a new key phrase hint item.

[10]
Theorem â€œSuccessorâ€: suc n = n + 1
Proof:
  By induction on `n : â„•`:
    Base case:
        0 + 1
      =âŸ¨ â€œDefinition of + for 0â€ âŸ©
        1
      =âŸ¨ Fact `1 = suc 0` âŸ©
        suc 0
    Induction step:
        suc n + 1
      =âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
        suc (n + 1)
      =âŸ¨ Induction hypothesis âŸ©
        suc suc n

Theorem â€œSuccessorâ€: suc n = n + 1
Proof:
    By induction on `n : â„•`:
        Base case:
            Calculation for expected goal  `suc 0 = 0 + 1`:
                    0 + 1
                = âŸ¨ â€œDefinition of + for 0â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for 0â€
                        â€” CalcCheck: â”€ OK
                    1
                = âŸ¨ Fact `1 = suc 0` âŸ©
                        â€” CalcCheck: â”€ OK
                    suc 0            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK
        Induction step:
            Calculation for expected goal  `suc (suc n) = suc n + 1`:
                    suc n + 1
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc (n + 1)
                = âŸ¨ Induction hypothesis âŸ©
                        â€” CalcCheck: Found induction hypothesis `suc n = n + 1`
                        â€” CalcCheck: â”€ OK
                    suc (suc n)            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK    
    â€” CalcCheck: Base case and induction step both present   
    â€” CalcCheck: Induction proof OK
[11]
When a theorem contains multiple variables of type â„•, you have to choose on which to induct (or on which to induct first) (if induction is needed at all).

In the case of â€œShifting suc over +â€, you notice that addition is involved, that the definition of + is inductive on the first argument, and that here, the first argument of + on both the left-hand and on the right-hand side is the variable m, so choosing an induction proof on m appears promising.

Complete the proofs by filling in the calculations â€” as usual, â€œ=âŸ¨ ? âŸ©â€ may need to be replaced with arbitrarily many steps.

[12]
Theorem â€œShifting `suc` over +â€: suc m + n = m + suc n
Proof:
  By induction on `m : â„•`:
    Base case:
        suc 0 + n
      =âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
        suc (0 + n)
      =âŸ¨ â€œLeft-identity of +â€ âŸ©
        suc n
      =âŸ¨ â€œLeft-identity of +â€âŸ©
        0 + suc n
    Induction step:
        suc (suc m) + n
      =âŸ¨ â€œDefinition of + for `suc`â€âŸ©
        suc (suc m + n)
      =âŸ¨ Induction hypothesis âŸ©
        suc (m + suc n)
      =âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
        suc m + suc n

Theorem â€œShifting `suc` over +â€: suc m + n = m + suc n
Proof:
    By induction on `m : â„•`:
        Base case:
            Calculation for expected goal  `suc 0 + n = 0 + suc n`:
                    suc 0 + n
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc (0 + n)
                = âŸ¨ â€œLeft-identity of +â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for 0â€
                        â€” CalcCheck: â”€ OK
                    suc n
                = âŸ¨ â€œLeft-identity of +â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for 0â€
                        â€” CalcCheck: â”€ OK
                    0 + suc n            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK
        Induction step:
            Calculation for expected goal  `suc (suc m) + n = suc m + suc n`:
                    suc (suc m) + n
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc (suc m + n)
                = âŸ¨ Induction hypothesis âŸ©
                        â€” CalcCheck: Found induction hypothesis `suc m + n = m + suc n`
                        â€” CalcCheck: â”€ OK
                    suc (m + suc n)
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc m + suc n            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK    
    â€” CalcCheck: Base case and induction step both present   
    â€” CalcCheck: Induction proof OK
[13]
Now do the next proof yourself â€” remember that in exams, you may need to create induction proofs without being able to copy a skeleton from elsewhere, so practice to manually enter induction proofs with the right indentation structure, and typically using keyword completion several times!

[14]
Theorem â€œSymmetry of +â€: m + n = n + m
Proof:
  By induction on `m : â„•`:
    Base case: 
        0 + n
      =âŸ¨ â€œLeft-identity of +â€âŸ©
        n
      =âŸ¨ â€œRight-identity of +â€âŸ©
        n + 0
    Induction step :
        suc m + n
      =âŸ¨ â€œDefinition of + for `suc`â€âŸ©
        suc (m + n)
      =âŸ¨ Induction hypothesis âŸ©
        suc (n + m)
      =âŸ¨ â€œDefinition of + for `suc`â€âŸ©
        (suc n) + m
      =âŸ¨ â€œShifting `suc` over +â€âŸ©
        n + suc m

Theorem â€œSymmetry of +â€: m + n = n + m
Proof:
    By induction on `m : â„•`:
        Base case:
            Calculation for expected goal  `0 + n = n + 0`:
                    0 + n
                = âŸ¨ â€œLeft-identity of +â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for 0â€
                        â€” CalcCheck: â”€ OK
                    n
                = âŸ¨ â€œRight-identity of +â€ âŸ©
                        â€” CalcCheck: Found â€œRight-identity of +â€
                        â€” CalcCheck: â”€ OK
                    n + 0            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK
        Induction step:
            Calculation for expected goal  `suc m + n = n + suc m`:
                    suc m + n
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc (m + n)
                = âŸ¨ Induction hypothesis âŸ©
                        â€” CalcCheck: Found induction hypothesis `m + n = n + m`
                        â€” CalcCheck: â”€ OK
                    suc (n + m)
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc n + m
                = âŸ¨ â€œShifting `suc` over +â€ âŸ©
                        â€” CalcCheck: Found â€œShifting `suc` over +â€
                        â€” CalcCheck: â”€ OK
                    n + suc m            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK    
    â€” CalcCheck: Base case and induction step both present   
    â€” CalcCheck: Induction proof OK
[15]
Doubling
[16]
Declaration: double : â„• â†’ â„•

Declaration: double : â„• â†’ â„•
[17]
Just for fun, we introduce this doubling function via an inductive definition:

[18]
Axiom â€œDefinition of `double`â€:  double 0 = 0
Axiom â€œDefinition of `double`â€:  double (suc n) = 2 + double n

Axiom â€œDefinition of `double`â€: double 0 = 0
Axiom â€œDefinition of `double`â€: double (suc n) = 2 + double n
[19]
We can then prove that this function actually implements doubling via addition of the argument to itself:

[20]
Theorem â€œDoublingâ€:  double n = n + n
Proof:
  By induction on `n : â„•`:
    Base case:
        double 0
      =âŸ¨ â€œDefinition of `double`â€ âŸ©
        0
      =âŸ¨ â€œRight-identity of +â€âŸ©
        0 + 0
    Induction step:
        double (suc n)
      =âŸ¨ â€œDefinition of `double`â€ âŸ©
        2 + double n
      =âŸ¨ Induction hypothesis âŸ©
        2 + (n + n)
      =âŸ¨ Fact `2 = suc 1` âŸ©
        suc 1 + (n + n)
      =âŸ¨ â€œShifting `suc` over +â€âŸ©
        1 + suc (n + n)
      =âŸ¨ â€œDefinition of + for `suc`â€âŸ©
        1 + (suc n + n)
      =âŸ¨ â€œSymmetry of +â€âŸ©
        (n + suc n) + 1
      =âŸ¨ â€œSuccessorâ€âŸ©
        suc (n + suc n)
      =âŸ¨ â€œDefinition of + for `suc`â€âŸ©
        suc n + suc n


        



        

      

Theorem â€œDoublingâ€: double n = n + n
Proof:
    By induction on `n : â„•`:
        Base case:
            Calculation for expected goal  `double 0 = 0 + 0`:
                    double 0
                = âŸ¨ â€œDefinition of `double`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of `double`â€
                        â€” CalcCheck: â”€ OK
                    0
                = âŸ¨ â€œRight-identity of +â€ âŸ©
                        â€” CalcCheck: Found â€œRight-identity of +â€
                        â€” CalcCheck: â”€ OK
                    0 + 0            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK
        Induction step:
            Calculation for expected goal  `double (suc n) = suc n + suc n`:
                    double (suc n)
                = âŸ¨ â€œDefinition of `double`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of `double`â€
                        â€” CalcCheck: â”€ OK
                    2 + double n
                = âŸ¨ Induction hypothesis âŸ©
                        â€” CalcCheck: Found induction hypothesis `double n = n + n`
                        â€” CalcCheck: â”€ OK
                    2 + (n + n)
                = âŸ¨ Fact `2 = suc 1` âŸ©
                        â€” CalcCheck: â”€ OK
                    suc 1 + (n + n)
                = âŸ¨ â€œShifting `suc` over +â€ âŸ©
                        â€” CalcCheck: Found â€œShifting `suc` over +â€
                        â€” CalcCheck: â”€ OK
                    1 + suc (n + n)
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    1 + (suc n + n)
                = âŸ¨ â€œSymmetry of +â€ âŸ©
                        â€” CalcCheck: Found â€œSymmetry of +â€
                        â€” CalcCheck: â”€ OK
                    (n + suc n) + 1
                = âŸ¨ â€œSuccessorâ€ âŸ©
                        â€” CalcCheck: Found â€œSuccessorâ€
                        â€” CalcCheck: â”€ OK
                    suc (n + suc n)
                = âŸ¨ â€œDefinition of + for `suc`â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of + for `suc`â€
                        â€” CalcCheck: â”€ OK
                    suc n + suc n            
            â€” CalcCheck: All steps OK           
            â€” CalcCheck: Calculation matches goal â”€ OK    
    â€” CalcCheck: Base case and induction step both present   
    â€” CalcCheck: Induction proof OK
[21]
Feedback
[22]
This was (every answer is right; â€œno answerâ€ is wrong):

  all very easy
  generally easy
  OK
  occasionally hard
  mostly hard
  all very hard
[23]
This was (every answer is right; â€œno answerâ€ is wrong):

  all very boring
  mostly boring
  OK
  occasionally interesting
  mostly interesting
  all very interesting
[24]
Concluding Declaration
[25]
Your answers above are completely your own work? (â€œNo answerâ€ is wrong.)

  Yes
  No