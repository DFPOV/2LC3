â€” Homework 9 Notebook 1: Using Explicit Induction Principles
[1]
Here we redevelop the theory of the natural numbers from scratch â€” nothing about the natural numbers is preloaded here.

Instead of having the successor operator suc, we base induction on 0 and (_+ 1), using an explicitly stated induction principle instead of built-in â€œBy inductionâ€, which is disabled here. (Evaluation is also not available here.)

Using (_+ 1) instead of suc will make some proofs easier once in particular symmetry of addition is activated. (But not in this notebook.)

Using (_+ 1) instead of suc also brings the presentation closer to what you will see in many other places, including LADM chapter 12.

(All propositional logic and predicate logic are preloaded here, and four hint items are allowed per hint.)

[2]
Weak Induction on Natural Numbers
[3]
The type â„• of natural numbers is set up here so that natural-number literals (such as â€œ0â€ and â€œ1â€) can be used as constants of type â„•, but no operations on â„• are registered â€” not even suc.

[4]
Addition
[5]
Instead of introducing the constructor suc, we will be using addition of 1, so we need to first introduce addition:

[6]
Declaration: _+_ : â„• â†’ â„• â†’ â„•

Declaration: _+_ : â„• â†’ (â„• â†’ â„•)   
    â€” CalcCheck: Operator _+_: Associating to the left; precedence 100
[7]
With this, we can already formulate a first axiom:

[8]
Axiom â€œZero is not successorâ€: 0 = n + 1  â‰¡  false

Axiom â€œZero is not successorâ€: 0 = n + 1 â‰¡ false
[9]
A different shape of this is occasionally useful:

[10]
Theorem â€œZero is not successorâ€: 0 â‰  n + 1
Proof:
    0 â‰  n + 1
  â‰¡âŸ¨ â€œDefinition of â‰ â€âŸ©
    Â¬ (0 = n + 1)
  â‰¡âŸ¨ â€œZero is not successorâ€âŸ©
    Â¬ false
  â‰¡âŸ¨ â€œNegation of `false`â€âŸ©
    true  

Theorem â€œZero is not successorâ€: 0 â‰  n + 1
Proof:
    Calculation for expected goal  `0 â‰  n + 1`:
            0 â‰  n + 1
        â‰¡ âŸ¨ â€œDefinition of â‰ â€ âŸ©
                â€” CalcCheck: Found â€œDefinition of â‰ â€, â€œDefinition of â‰ â€
                â€” CalcCheck: â”€ OK
            Â¬ (0 = n + 1)
        â‰¡ âŸ¨ â€œZero is not successorâ€ âŸ©
                â€” CalcCheck: Found â€œZero is not successorâ€
                â€” CalcCheck: â”€ OK
            Â¬ false
        â‰¡ âŸ¨ â€œNegation of `false`â€ âŸ©
                â€” CalcCheck: Found (3.13) â€œNegation of `false`â€
                â€” CalcCheck: â”€ OK
            true    
    â€” CalcCheck: All steps OK   
    â€” CalcCheck: Calculation matches goal â”€ OK
[11]
Addition is defined by just translating the suc-based definition into using (_+ 1) instead:

[12]
Axiom â€œDefinition of +â€: 0 + n = n
Axiom â€œDefinition of +â€: (m + 1) + n = (m + n) + 1

Axiom â€œDefinition of +â€: 0 + n = n
Axiom â€œDefinition of +â€: (m + 1) + n = (m + n) + 1
[13]
In this version, natural induction corresponding to that implemented by â€œBy induction on var : â„•â€ relies on the following induction principle:

[14]
Axiom â€œInduction over â„•â€:
   P[n â‰” 0]
   â‡’ (âˆ€ n : â„• â™ P â€¢ P[n â‰” n + 1])
   â‡’ (âˆ€ n : â„• â€¢ P)

Axiom â€œInduction over â„•â€: P[n â‰” 0] â‡’ ((âˆ€ n : â„• â™ P â€¢ P[n â‰” n + 1] ) â‡’ (âˆ€ n : â„• â€¢ P ))   
    â€” CalcCheck: Metavariables: P = Pã€–nã€—
[15]
This can be used to prove properties of the shape (âˆ€ n : â„• â€¢ P) by supplying subproofs for the base case P[n â‰” 0] and the induction step (âˆ€ n : â„• â™ P â€¢ P[n â‰” n + 1]), as demonstrated in the following example:

Important: Using â€œInduction over â„•â€ with two subproofs can only prove universally-quantified goals, that is, goals of shape (âˆ€ n : â„• â€¢ P)!

[16]
Theorem â€œRight-identity of + (v0)â€: âˆ€ m : â„• â€¢ m + 0 = m
Proof:
  Using â€œInduction over â„•â€: 
    Subproof for `(m + 0 = m)[m â‰” 0]`:
      By substitution and â€œDefinition of +â€
    Subproof for `âˆ€ m : â„• â™ m + 0 = m â€¢ (m + 0 = m)[m â‰” m + 1]`:
      For any `m : â„•` satisfying `m + 0 = m`:
          (m + 0 = m)[m â‰” m + 1]
        =âŸ¨ Substitution, â€œDefinition of +â€ âŸ©
          (m + 0) + 1 = m + 1
        =âŸ¨ Assumption `m + 0 = m`, â€œReflexivity of =â€ âŸ©
          true

Theorem â€œRight-identity of + (v0)â€: (âˆ€ m : â„• â€¢ m + 0 = m )
Proof:
    Using â€œInduction over â„•â€:       
        â€” CalcCheck: Found â€œInduction over â„•â€
        Subproof for `(m + 0 = m)[m â‰” 0]`:
            By Substitution, â€œDefinition of +â€               
                â€” CalcCheck: Found â€œDefinition of +â€
        Subproof for `(âˆ€ m : â„• â™ m + 0 = m â€¢ (m + 0 = m)[m â‰” m + 1] )`:
            For any ` m : â„•` satisfying `m + 0 = m`:           
            â€” CalcCheck: Assumptions match quantifier range.
                Calculation for expected goal  `(m + 0 = m)[m â‰” m + 1]`:
                        (m + 0 = m)[m â‰” m + 1]
                    = âŸ¨ Substitution, â€œDefinition of +â€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of +â€
                            â€” CalcCheck: â”€ OK
                        (m + 0) + 1 = m + 1
                    = âŸ¨ Assumption `m + 0 = m`, â€œReflexivity of =â€ âŸ©
                            â€” CalcCheck: Found assumption `m + 0 = m`
                            â€” CalcCheck: Found (1.2) â€œReflexivity of =â€
                            â€” CalcCheck: â”€ OK
                        true                
                â€” CalcCheck: All steps OK               
                â€” CalcCheck: Calculation matches goal â”€ OK
[17]
The substitutions in the subproof goals can be taken care of automatically, significantly reducing the overhead of this presentation:

[18]
Theorem â€œRight-identity of + (v1)â€: âˆ€ m : â„• â€¢ m + 0 = m
Proof:
  Using â€œInduction over â„•â€:
    Subproof for `0 + 0 = 0`:
      By â€œDefinition of +â€
    Subproof for `âˆ€ m : â„• â™ m + 0 = m â€¢ (m + 1) + 0 = m + 1`:
      For any `m : â„•` satisfying `m + 0 = m`:
          (m + 1) + 0
        =âŸ¨ â€œDefinition of +â€ âŸ©
          (m + 0) + 1
        =âŸ¨ Assumption `m + 0 = m` âŸ©
          m + 1

Theorem â€œRight-identity of + (v1)â€: (âˆ€ m : â„• â€¢ m + 0 = m )
Proof:
    Using â€œInduction over â„•â€:       
        â€” CalcCheck: Found â€œInduction over â„•â€
        Subproof for `0 + 0 = 0`:
            By â€œDefinition of +â€               
                â€” CalcCheck: Found â€œDefinition of +â€
        Subproof for `(âˆ€ m : â„• â™ m + 0 = m â€¢ (m + 1) + 0 = m + 1 )`:
            For any ` m : â„•` satisfying `m + 0 = m`:           
            â€” CalcCheck: Assumptions match quantifier range.
                Calculation for expected goal  `(m + 1) + 0 = m + 1`:
                        (m + 1) + 0
                    = âŸ¨ â€œDefinition of +â€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of +â€
                            â€” CalcCheck: â”€ OK
                        (m + 0) + 1
                    = âŸ¨ Assumption `m + 0 = m` âŸ©
                            â€” CalcCheck: Found assumption `m + 0 = m`
                            â€” CalcCheck: â”€ OK
                        m + 1                
                â€” CalcCheck: All steps OK               
                â€” CalcCheck: Calculation matches goal â”€ OK
[19]
And as long as the subproofs make their goals obvious, the subproof goals can be omitted, too, making the presentation look almost the same as in H4.1:

[20]
Theorem â€œRight-identity of + (v2)â€: âˆ€ m : â„• â€¢ m + 0 = m
Proof:
  Using â€œInduction over â„•â€:
    Subproof:
        0 + 0
      =âŸ¨ â€œDefinition of +â€ âŸ©
        0
    Subproof:
      For any `m : â„•` satisfying â€œIndHypâ€ `m + 0 = m`:
          (m + 1) + 0
        =âŸ¨ â€œDefinition of +â€ âŸ©
          (m + 0) + 1
        =âŸ¨ Assumption â€œIndHypâ€ âŸ©
          m + 1

Theorem â€œRight-identity of + (v2)â€: (âˆ€ m : â„• â€¢ m + 0 = m )
Proof:
    Using â€œInduction over â„•â€:       
        â€” CalcCheck: Found â€œInduction over â„•â€
        Subproof establishing `0 + 0 = 0`:
                    0 + 0
                = âŸ¨ â€œDefinition of +â€ âŸ©
                        â€” CalcCheck: Found â€œDefinition of +â€
                        â€” CalcCheck: â”€ OK
                    0            
            â€” CalcCheck: All steps OK
        Subproof establishing `(âˆ€ m : â„• â™ m + 0 = m â€¢ (m + 1) + 0 = m + 1 )`:
            For any ` m : â„•` satisfying â€œIndHypâ€ `m + 0 = m`:           
            â€” CalcCheck: Assumptions match quantifier range.
                Calculation establishing  `(m + 1) + 0 = m + 1`:
                        (m + 1) + 0
                    = âŸ¨ â€œDefinition of +â€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of +â€
                            â€” CalcCheck: â”€ OK
                        (m + 0) + 1
                    = âŸ¨ Assumption â€œIndHypâ€ âŸ©
                            â€” CalcCheck: Found assumption â€œIndHypâ€
                            â€” CalcCheck: â”€ OK
                        m + 1                
                â€” CalcCheck: All steps OK
[21]
And if a theorem statement without explicit universal quantification is desired, one can just adapt this proof accordingly:

[22]
Theorem â€œRight-identity of +â€:  m + 0 = m
Proof:
      m + 0 = m
    â‰¡ âŸ¨ Substitution âŸ©
      (m + 0 = m)[m â‰” m]
    â‡ âŸ¨ â€œInstantiationâ€ âŸ©
      âˆ€ m : â„• â€¢ m + 0 = m
  Proof for this:
    Using â€œInduction over â„•â€:
      Subproof:
          0 + 0
        =âŸ¨ â€œDefinition of +â€ âŸ©
          0
      Subproof:
        For any `m : â„•` satisfying â€œIndHypâ€ `m + 0 = m`:
            (m + 1) + 0
          =âŸ¨ â€œDefinition of +â€ âŸ©
            (m + 0) + 1
          =âŸ¨ Assumption â€œIndHypâ€ âŸ©
            m + 1

Theorem â€œRight-identity of +â€: m + 0 = m
Proof:
        Calculation for expected goal  `m + 0 = m`:
                m + 0 = m
            â‰¡ âŸ¨ Substitution âŸ©
                    â€” CalcCheck: â”€ OK
                (m + 0 = m)[m â‰” m]
            â‡ âŸ¨ â€œInstantiationâ€ âŸ©
                    â€” CalcCheck: Found (9.13) â€œInstantiationâ€, (9.13.2) â€œInstantiationâ€, (9.13.1) â€œInstantiationâ€
                    â€” CalcCheck: â”€ OK
                (âˆ€ m : â„• â€¢ m + 0 = m )        
        â€” CalcCheck: All steps OK       
        â€” CalcCheck: Calculation matches goal â”€ OK
    Proof for this:
        Using â€œInduction over â„•â€:           
            â€” CalcCheck: Found â€œInduction over â„•â€
            Subproof establishing `0 + 0 = 0`:
                        0 + 0
                    = âŸ¨ â€œDefinition of +â€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of +â€
                            â€” CalcCheck: â”€ OK
                        0                
                â€” CalcCheck: All steps OK
            Subproof establishing `(âˆ€ m : â„• â™ m + 0 = m â€¢ (m + 1) + 0 = m + 1 )`:
                For any ` m : â„•` satisfying â€œIndHypâ€ `m + 0 = m`:               
                â€” CalcCheck: Assumptions match quantifier range.
                    Calculation establishing  `(m + 1) + 0 = m + 1`:
                            (m + 1) + 0
                        = âŸ¨ â€œDefinition of +â€ âŸ©
                                â€” CalcCheck: Found â€œDefinition of +â€
                                â€” CalcCheck: â”€ OK
                            (m + 0) + 1
                        = âŸ¨ Assumption â€œIndHypâ€ âŸ©
                                â€” CalcCheck: Found assumption â€œIndHypâ€
                                â€” CalcCheck: â”€ OK
                            m + 1                    
                    â€” CalcCheck: All steps OK
[23]
(However, as long as no explicit substitution needs to be provided, the version with explicit universal quantification, â€œRight-identity of + (v2)â€, is just as useful as the version without, due to automatic instantiation as explained in H8.1.)

[24]
In H4.1, you have used the built-in induction support to prove:

    Theorem â€œShifting `suc` over +â€: suc m + n = m + suc n
An application of â€œInduction over â„•â€ for this will be proving a goal of shape â€œâˆ€ m : â„• â€¢ ...â€.

Since mixing explicit and implicit universal quantification is somewhat dubious stylistically, and also can induce technical problems, a natural way to state theorems here will actually quantify all variables explicitly â€” this mainly means that additional â€œFor anyâ€ structures will be needed in the proofs. (Feel free to add the subproof goals if you wish.)

[25]
Theorem â€œShifting successor over +â€: âˆ€ m â€¢ âˆ€ n â€¢ (m + 1) + n = m + (n + 1)
Proof:
  Using â€œInduction over â„•â€:
    Subproof:
      For any `n : â„•`:
          (0 + 1) + n
        =âŸ¨ â€œDefinition of +â€âŸ© 
          0 + (n + 1)
    Subproof:
      For any `m : â„•` satisfying â€œIndHypâ€ `âˆ€ n â€¢ (m + 1) + n = m + (n + 1)`:
        For any `n : â„•`:
            (m + 1 + 1) + n
          =âŸ¨â€œDefinition of +â€ âŸ©
            ((m + 1) + n) + 1
          =âŸ¨ Assumption â€œIndHypâ€âŸ©
            (m + (n + 1)) + 1
          =âŸ¨ â€œDefinition of +â€ âŸ©
            (m + 1) + (n + 1)

Theorem â€œShifting successor over +â€: (âˆ€ m â€¢ (âˆ€ n â€¢ (m + 1) + n = m + (n + 1) ) )
Proof:
    Using â€œInduction over â„•â€:       
        â€” CalcCheck: Found â€œInduction over â„•â€
        Subproof establishing `(âˆ€ n : â„• â€¢ (0 + 1) + n = 0 + (n + 1) )`:
            For any ` n : â„•`:
                Calculation establishing  `(0 + 1) + n = 0 + (n + 1)`:
                        (0 + 1) + n
                    = âŸ¨ â€œDefinition of +â€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of +â€
                            â€” CalcCheck: â”€ OK
                        0 + (n + 1)                
                â€” CalcCheck: All steps OK
        Subproof establishing `(âˆ€ m : â„• â™ (âˆ€ n â€¢ (m + 1) + n = m + (n + 1) ) â€¢ (âˆ€ n : â„• â€¢ ((m + 1) + 1) + n = (m + 1) + (n + 1) ) )`:
            For any ` m : â„•` satisfying â€œIndHypâ€ `(âˆ€ n â€¢ (m + 1) + n = m + (n + 1) )`:           
            â€” CalcCheck: Assumptions match quantifier range.
                For any ` n : â„•`:
                    Calculation establishing  `((m + 1) + 1) + n = (m + 1) + (n + 1)`:
                            ((m + 1) + 1) + n
                        = âŸ¨ â€œDefinition of +â€ âŸ©
                                â€” CalcCheck: Found â€œDefinition of +â€
                                â€” CalcCheck: â”€ OK
                            ((m + 1) + n) + 1
                        = âŸ¨ Assumption â€œIndHypâ€ âŸ©
                                â€” CalcCheck: Found assumption â€œIndHypâ€
                                â€” CalcCheck: â”€ OK
                            (m + (n + 1)) + 1
                        = âŸ¨ â€œDefinition of +â€ âŸ©
                                â€” CalcCheck: Found â€œDefinition of +â€
                                â€” CalcCheck: â”€ OK
                            (m + 1) + (n + 1)                    
                    â€” CalcCheck: All steps OK
[26]
Using this, you can now also prove â€œSymmetry of +â€:

[27]
Theorem â€œSymmetry of +â€: âˆ€ m â€¢ âˆ€ n â€¢ m + n = n + m
Proof:
    Using â€œInduction over â„•â€:
      Subproof:
        For any `n : â„•`:
            0 + n
          =âŸ¨â€œDefinition of +â€âŸ©
            n
          =âŸ¨â€œRight-identity of +â€âŸ©
            n + 0 
      Subproof:
        For any `m : â„•` satisfying â€œAâ€ `âˆ€ n â€¢ m + n = n + m`:
          For any `n : â„•`:
              (m + 1) + n
            =âŸ¨ â€œDefinition of +â€âŸ© 
              (m + n) + 1
            =âŸ¨ Assumption â€œAâ€âŸ©
              n + m + 1
            =âŸ¨ â€œDefinition of +â€âŸ©
              (n + 1) + m 
            =âŸ¨ â€œShifting successor over +â€âŸ©
              n + (m + 1)

Theorem â€œSymmetry of +â€: (âˆ€ m â€¢ (âˆ€ n â€¢ m + n = n + m ) )
Proof:
    Using â€œInduction over â„•â€:       
        â€” CalcCheck: Found â€œInduction over â„•â€
        Subproof establishing `(âˆ€ n : â„• â€¢ 0 + n = n + 0 )`:
            For any ` n : â„•`:
                Calculation establishing  `0 + n = n + 0`:
                        0 + n
                    = âŸ¨ â€œDefinition of +â€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of +â€
                            â€” CalcCheck: â”€ OK
                        n
                    = âŸ¨ â€œRight-identity of +â€ âŸ©
                            â€” CalcCheck: Found â€œRight-identity of +â€
                            â€” CalcCheck: â”€ OK
                        n + 0                
                â€” CalcCheck: All steps OK
        Subproof establishing `(âˆ€ m : â„• â™ (âˆ€ n â€¢ m + n = n + m ) â€¢ (âˆ€ n : â„• â€¢ (m + 1) + n = n + (m + 1) ) )`:
            For any ` m : â„•` satisfying â€œAâ€ `(âˆ€ n â€¢ m + n = n + m )`:           
            â€” CalcCheck: Assumptions match quantifier range.
                For any ` n : â„•`:
                    Calculation establishing  `(m + 1) + n = n + (m + 1)`:
                            (m + 1) + n
                        = âŸ¨ â€œDefinition of +â€ âŸ©
                                â€” CalcCheck: Found â€œDefinition of +â€
                                â€” CalcCheck: â”€ OK
                            (m + n) + 1
                        = âŸ¨ Assumption â€œAâ€ âŸ©
                                â€” CalcCheck: Found assumption â€œAâ€
                                â€” CalcCheck: â”€ OK
                            (n + m) + 1
                        = âŸ¨ â€œDefinition of +â€ âŸ©
                                â€” CalcCheck: Found â€œDefinition of +â€
                                â€” CalcCheck: â”€ OK
                            (n + 1) + m
                        = âŸ¨ â€œShifting successor over +â€ âŸ©
                                â€” CalcCheck: Found â€œShifting successor over +â€
                                â€” CalcCheck: â”€ OK
                            n + (m + 1)                    
                    â€” CalcCheck: All steps OK
[28]
Note that symmetry and associativity of addition are not activated here, so their uses will need to be made explicit below where necessary.

[29]
Sequences from the Back
[30]
(Before you continue here, make sure you are familiar with â€œ`By induction on â€¦â€™â€ proofs for sequences as explained and practiced in Exercises 6.1 amd 6.2!)

[31]
In this notebook, we consider the â€œsnocâ€ constructor _â–¹_ for sequences as primitive and introduce the sequence type also without setup for â€œBy induction on `xs : Seq A`â€:

[32]
Declaration: Seq : Type â†’ Type

Declaration: Seq : Type â†’ Type
[33]
Declaration: ğœ– : Seq A
Declaration: _â–¹_ : Seq A â†’ A â†’ Seq A

Declaration: ğœ– : Seq A
Declaration: _â–¹_ : Seq A â†’ (A â†’ Seq A)   
    â€” CalcCheck: Operator _â–¹_: Associating to the left; precedence 60
[34]
Axiom â€œSnoc is not emptyâ€: âˆ€ xs â€¢ âˆ€ x â€¢  xs â–¹ x = ğœ–  â‰¡  false

Axiom â€œSnoc is not emptyâ€: (âˆ€ xs â€¢ (âˆ€ x â€¢ xs â–¹ x = ğœ– â‰¡ false ) )
[35]
Axiom â€œEquality of â–¹â€ â€œInjectivity of â–¹â€ â€œCancellation of â–¹â€:
   xs â–¹ x  =  ys â–¹ y   â‰¡   xs = ys  âˆ§  x = y

Axiom â€œEquality of â–¹â€ â€œInjectivity of â–¹â€ â€œCancellation of â–¹â€: xs â–¹ x = ys â–¹ y â‰¡ xs = ys âˆ§ x = y
[36]
We only provide the â–¹-based induction principle for sequences here:

[37]
Axiom â€œSnoc-induction over sequencesâ€:
    P[xs â‰” ğœ–]
    â‡’ (âˆ€ xs : Seq A â™ P â€¢ (âˆ€ x : A â€¢ P[xs â‰” xs â–¹ x]))
    â‡’ (âˆ€ xs : Seq A â€¢ P)

Axiom â€œSnoc-induction over sequencesâ€: P[xs â‰” ğœ–] â‡’ ((âˆ€ xs : Seq A â™ P â€¢ (âˆ€ x : A â€¢ P[xs â‰” xs â–¹ x] ) ) â‡’ (âˆ€ xs : Seq A â€¢ P ))   
    â€” CalcCheck: Metavariables: A = Aã€–ã€—, P = Pã€–xsã€—   
    â€” CalcCheck: Proviso: Â¬occurs(`x`, `P`), Â¬occurs(`xs`, `A`)
[38]
Then we define cons _â—ƒ_ in terms of snoc _â–¹_:

[39]
Declaration: _â—ƒ_ : A â†’ Seq A â†’ Seq A

Declaration: _â—ƒ_ : A â†’ (Seq A â†’ Seq A)   
    â€” CalcCheck: Operator _â—ƒ_: Associating to the right; precedence 60
[40]
Axiom â€œDefinition of â—ƒâ€:  x â—ƒ ğœ– = ğœ– â–¹ x
Axiom â€œDefinition of â—ƒâ€:  x â—ƒ (xs â–¹ y) = (x â—ƒ xs) â–¹ y

Axiom â€œDefinition of â—ƒâ€: x â—ƒ ğœ– = ğœ– â–¹ x
Axiom â€œDefinition of â—ƒâ€: x â—ƒ (xs â–¹ y) = (x â—ƒ xs) â–¹ y
[41]
In this context, â€œCons is not emptyâ€ does not need to be an axiom, but can be shown as a theorem, and you will need to use â€œSnoc-induction over sequencesâ€ to prove it:

[42]
Theorem â€œCons is not emptyâ€: âˆ€ xs â€¢ âˆ€ x â€¢  x â—ƒ xs = ğœ–  â‰¡  false
Proof:
  Using â€œSnoc-induction over sequencesâ€:
    Subproof:
      For any `x : A`:
          x â—ƒ ğœ– = ğœ– â‰¡ false
        â‰¡âŸ¨ â€œDefinition of â—ƒâ€âŸ©
          false â‰¡ ğœ– = ğœ– â–¹ x
        â‰¡âŸ¨ â€œSnoc is not emptyâ€âŸ©
          false â‰¡ false
        â‰¡âŸ¨ â€œIdentity of â‰¡â€âŸ©
          true 
    Subproof:
      For any `xs : Seq A` satisfying â€œIndHypâ€ `âˆ€ x â€¢  x â—ƒ xs = ğœ–  â‰¡  false`:
        For any `z : A`, `x : A`:
            (x â—ƒ (xs â–¹ z) = ğœ–) â‰¡ false
          â‰¡âŸ¨ â€œDefinition of â—ƒâ€âŸ©
            ((x â—ƒ xs) â–¹ z = ğœ–) â‰¡ false
          â‰¡âŸ¨ â€œSnoc is not emptyâ€ âŸ©
            false â‰¡ false
          â‰¡âŸ¨ â€œIdentity of â‰¡â€âŸ©
            true 

    

Theorem â€œCons is not emptyâ€: (âˆ€ xs â€¢ (âˆ€ x â€¢ x â—ƒ xs = ğœ– â‰¡ false ) )
Proof:
    Using â€œSnoc-induction over sequencesâ€:       
        â€” CalcCheck: Found â€œSnoc-induction over sequencesâ€
        Subproof establishing `(âˆ€ x : A â€¢ x â—ƒ ğœ– = ğœ– â‰¡ false )`:
            For any ` x : A`:
                Calculation establishing  `x â—ƒ ğœ– = ğœ– â‰¡ false`:
                        x â—ƒ ğœ– = ğœ– â‰¡ false
                    â‰¡ âŸ¨ â€œDefinition of â—ƒâ€ âŸ©
                            â€” CalcCheck: Found â€œDefinition of â—ƒâ€
                            â€” CalcCheck: â”€ OK
                        false â‰¡ ğœ– = ğœ– â–¹ x
                    â‰¡ âŸ¨ â€œSnoc is not emptyâ€ âŸ©
                            â€” CalcCheck: Found â€œSnoc is not emptyâ€
                            â€” CalcCheck: â”€ OK
                        false â‰¡ false
                    â‰¡ âŸ¨ â€œIdentity of â‰¡â€ âŸ©
                            â€” CalcCheck: Found (3.3) â€œIdentity of â‰¡â€
                            â€” CalcCheck: â”€ OK
                        true                
                â€” CalcCheck: All steps OK
        Subproof establishing `(âˆ€ xs : Seq A â™ (âˆ€ x â€¢ x â—ƒ xs = ğœ– â‰¡ false ) â€¢ (âˆ€ z : A â€¢ (âˆ€ x : A â€¢ x â—ƒ (xs â–¹ z) = ğœ– â‰¡ false ) ) )`:
            For any ` xs : Seq A` satisfying â€œIndHypâ€ `(âˆ€ x â€¢ x â—ƒ xs = ğœ– â‰¡ false )`:           
            â€” CalcCheck: Assumptions match quantifier range.
                For any ` z : A`:
                    For any ` x : A`:
                        Calculation establishing  `x â—ƒ (xs â–¹ z) = ğœ– â‰¡ false`:
                                x â—ƒ (xs â–¹ z) = ğœ– â‰¡ false
                            â‰¡ âŸ¨ â€œDefinition of â—ƒâ€ âŸ©
                                    â€” CalcCheck: Found â€œDefinition of â—ƒâ€
                                    â€” CalcCheck: â”€ OK
                                (x â—ƒ xs) â–¹ z = ğœ– â‰¡ false
                            â‰¡ âŸ¨ â€œSnoc is not emptyâ€ âŸ©
                                    â€” CalcCheck: Found â€œSnoc is not emptyâ€
                                    â€” CalcCheck: â”€ OK
                                false â‰¡ false
                            â‰¡ âŸ¨ â€œIdentity of â‰¡â€ âŸ©
                                    â€” CalcCheck: Found (3.3) â€œIdentity of â‰¡â€
                                    â€” CalcCheck: â”€ OK
                                true                        
                        â€” CalcCheck: All steps OK
[43]
It turns out that proving â€œTail is differentâ€ is slightly easier with snoc induction (and can be very similar to the proof of â€œCons is not emptyâ€).

[44]
Theorem (13.7) â€œTail is differentâ€:
                 âˆ€ xs : Seq A â€¢ âˆ€ x : A â€¢ x â—ƒ xs = xs  â‰¡  false
Proof:
  Using â€œSnoc-induction over sequencesâ€:
    Subproof:
      For any `x : A`:
          (x â—ƒ ğœ– = ğœ–) â‰¡ false
        â‰¡âŸ¨ â€œCons is not emptyâ€âŸ©
          false â‰¡ false
        â‰¡âŸ¨ â€œIdentity of â‰¡â€âŸ©
          true
    Subproof:
      For any `xs : Seq A` satisfying â€œAâ€ `âˆ€ x â€¢ x â—ƒ xs = xs  â‰¡  false`:
        For any `z : A`, `x : A`:
            x â—ƒ (xs â–¹ z) = (xs â–¹ z) â‰¡ false
          =âŸ¨ â€œDefinition of â—ƒâ€âŸ©
            (x â—ƒ xs) â–¹ z = (xs â–¹ z) â‰¡ false 
          =âŸ¨ â€œDefinition of â‰ â€, â€œEquality of â–¹â€, â€œReflexivity of =â€âŸ© 
            Â¬ ((x â—ƒ xs) = xs âˆ§ true)
          =âŸ¨ â€œIdentity of âˆ§â€âŸ©
            Â¬ ((x â—ƒ xs) = xs)
          =âŸ¨ Assumption â€œAâ€âŸ©
            Â¬ false
          =âŸ¨ â€œNegation of `false`â€âŸ©
            true   

Theorem (13.7) â€œTail is differentâ€: (âˆ€ xs : Seq A â€¢ (âˆ€ x : A â€¢ x â—ƒ xs = xs â‰¡ false ) )   
    â€” CalcCheck: Metavariables: A = Aã€–ã€—   
    â€” CalcCheck: Proviso: Â¬occurs(`xs`, `A`)
Proof:
    Using â€œSnoc-induction over sequencesâ€:       
        â€” CalcCheck: Found â€œSnoc-induction over sequencesâ€
        Subproof establishing `(âˆ€ x : A â€¢ x â—ƒ ğœ– = ğœ– â‰¡ false )`:
            For any ` x : A`:
                Calculation establishing  `x â—ƒ ğœ– = ğœ– â‰¡ false`:
                        x â—ƒ ğœ– = ğœ– â‰¡ false
                    â‰¡ âŸ¨ â€œCons is not emptyâ€ âŸ©
                            â€” CalcCheck: Found â€œCons is not emptyâ€
                            â€” CalcCheck: â”€ OK
                        false â‰¡ false
                    â‰¡ âŸ¨ â€œIdentity of â‰¡â€ âŸ©
                            â€” CalcCheck: Found (3.3) â€œIdentity of â‰¡â€
                            â€” CalcCheck: â”€ OK
                        true                
                â€” CalcCheck: All steps OK
        Subproof establishing `(âˆ€ xs : Seq A â™ (âˆ€ x â€¢ x â—ƒ xs = xs â‰¡ false ) â€¢ (âˆ€ z : A â€¢ (âˆ€ x : A â€¢ x â—ƒ (xs â–¹ z) = xs â–¹ z â‰¡ false ) ) )`:
            For any ` xs : Seq A` satisfying â€œAâ€ `(âˆ€ x â€¢ x â—ƒ xs = xs â‰¡ false )`:           
            â€” CalcCheck: Assumptions match quantifier range.
                For any ` z : A`:
                    For any ` x : A`:
                        Calculation establishing  `x â—ƒ (xs â–¹ z) = xs â–¹ z â‰¡ false`:
                                x â—ƒ (xs â–¹ z) = xs â–¹ z â‰¡ false
                            = âŸ¨ â€œDefinition of â—ƒâ€ âŸ©
                                    â€” CalcCheck: Found â€œDefinition of â—ƒâ€
                                    â€” CalcCheck: â”€ OK
                                (x â—ƒ xs) â–¹ z = xs â–¹ z â‰¡ false
                            = âŸ¨ â€œDefinition of â‰ â€, â€œEquality of â–¹â€, â€œReflexivity of =â€ âŸ©
                                    â€” CalcCheck: Found â€œDefinition of â‰ â€, â€œDefinition of â‰ â€
                                    â€” CalcCheck: Found â€œEquality of â–¹â€
                                    â€” CalcCheck: Found (1.2) â€œReflexivity of =â€
                                    â€” CalcCheck: â”€ OK
                                Â¬ (x â—ƒ xs = xs âˆ§ true)
                            = âŸ¨ â€œIdentity of âˆ§â€ âŸ©
                                    â€” CalcCheck: Found (3.39) â€œIdentity of âˆ§â€
                                    â€” CalcCheck: â”€ OK
                                Â¬ (x â—ƒ xs = xs)
                            = âŸ¨ Assumption â€œAâ€ âŸ©
                                    â€” CalcCheck: Found assumption â€œAâ€
                                    â€” CalcCheck: â”€ OK
                                Â¬ false
                            = âŸ¨ â€œNegation of `false`â€ âŸ©
                                    â€” CalcCheck: Found (3.13) â€œNegation of `false`â€
                                    â€” CalcCheck: â”€ OK
                                true                        
                        â€” CalcCheck: All steps OK